# Задание "MultiReader"


## Общее для каждого пакета

- Запуск тестов - `make t`
- Проверка сборки приложения `make build`


## Базовая версия (easy)

- Условие для кандидата - [тут](easy/task.md)
- Шаблон для кандидата - [тут](easy/task.go)
- Эталонное решение - [тут](easy/task_expected.go)


## Продвинутая версия (hard)

- Условие для кандидата - [тут](hard/task.md)
- Шаблон для кандидата - [тут](hard/task.go)
- Эталонное решение - [тут](hard/task_expected.go)

## Идеи для улучшения

- Избежать склейки в один большой буфер: хранить окно как очередь блоков []byte и выдавать их по очереди вместо append в windowBuf, чтобы сократить копирования и перераспределения.
- Переиспользовать буферы: выделять блоки через sync.Pool вместо make на каждый toRead, чтобы снизить аллокации и давление на GC.
- Добавить проверку закрытия ридера сразу после закрытия канала данных в Read, чтобы в этом случае возвращать `io.ErrClosedPipe` вместо `io.EOF`.

## Вопросы по SD

- Последовательно читаем куски или частые случайные Seek. В чем разница работы программы?
- Какой лимит ОЗУ на экземпляр мультиридера (buffersNum * bufferSize + оверхед)?
- Что делаем при заполненном окне (блокируемся/применяем таймауты)?
- Что будет при одновременном вызове Read/Seek/Close?
- Как агрегировать ошибки в Close (цикл закрытия и join ошибок)?
- Как трактуем частично прочитанные данные и ошибку (отдать байты сейчас, ошибку в следующий вызов)?
