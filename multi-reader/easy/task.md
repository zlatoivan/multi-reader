# Задание "MultiReader"

Нужно написать структуру `MultiReader`, которая объединяет несколько источников данных в один непрерывный поток. 
Каждый источник данных реализует интерфейс `SizedReadSeekCloser`. Ваша структура `MultiReader` тоже должна реализовывать этот интерфейс.

Проще говоря: у вас есть несколько «кусочков» данных (ридеров). 
Нужно представить их как один длинный файл, у которого можно читать, перемещаться по позициям, закрывать и узнавать общий размер.

### Что нужно сделать

- Реализовать тип `MultiReader`.
- Реализовать конструктор:

```go
func NewMultiReader(rs ...SizedReadSeekCloser) *MultiReader
```

- Убедиться, что `MultiReader` реализует интерфейс `SizedReadSeekCloser`.

Интерфейс выглядит так:

```go
type SizedReadSeekCloser interface {
    io.ReadSeekCloser
    Size() int64
}
```

### Поведение методов MultiReader

- Read
  - Читает данные последовательно из всех переданных ридеров в том же порядке, в котором они даны в `NewMultiReader`.
  - Если буфер больше, чем остаётся данных в текущем ридере - чтение должно продолжиться из следующего. При переходе от одного ридера к следующему чтение продолжается без разрывов.
  - Соблюдайте стандартные правила `io.Reader`: если `len(p) == 0`, возвращайте `(0, nil)`; когда достигнут конец объединённых данных и ничего не прочитано в этом вызове — верните `io.EOF`.

- Seek
  - Перемещает текущую позицию чтения внутри объединённого потока.
  - Поддерживаются все варианты `whence`: `io.SeekStart`, `io.SeekCurrent`, `io.SeekEnd`.
  - Позиция должна находиться в диапазоне от `0` до общего размера, иначе возвращается ошибка.
  - Допускается выбирать момент фактического перемещения внутренних ридеров по своему усмотрению (немедленное/ленивое).

- Close
  - Должен закрыть все переданные ридеры.
  - После вызова Close дальнейшие вызовы Read и Seek должны возвращать ошибку `io.ErrClosedPipe`.
  - Повторный вызов Close допустим и возвращает nil (идемпотентность).

- Size
  - Возвращает суммарный размер данных всех ридеров.
  - Размер не должен пересчитываться заново при каждом вызове.

### Ограничения

- Предполагается, что суммарный размер данных всех ридеров укладывается в тип `int64` и переполнения не происходит.
- Size может вызываться и после Close; возвращает кэшированный суммарный размер.
- Seek на EOF допустим и Read возвращает EOF
- Не нужно обеспечивать потокобезопасность (конкурентность) — достаточно корректной работы в однопоточном сценарии.

### Шаблон кода

```go
/*
type io.ReadSeekCloser interface {
	Read(p []byte) (n int, err error)
	Seek(offset int64, whence int) (int64, error)
	Close() error
}
*/

package main

import "io"

type SizedReadSeekCloser interface {
	io.ReadSeekCloser
	Size() int64
}

type MultiReader struct {
	// put your code here...
}

func NewMultiReader(rs ...SizedReadSeekCloser) *MultiReader {
	// put your code here...
	return nil
}
```