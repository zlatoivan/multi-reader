## Задание "MultiReader с асинхронным буфером (prefetch)"

### Введение простыми словами

- **MultiReader**: представь, что у тебя несколько источников данных (например, несколько файлов). Мы хотим читать их как один длинный файл: сначала первый, затем второй и т.д.
- **Префетч (prefetch)**: это когда мы заранее читаем данные в память фоном, чтобы когда пользователь попросит `Read`, ответы были быстрее (данные уже под рукой в буфере). Это особенно полезно при последовательном чтении.

### Что нужно сделать

Реализовать в `task2` улучшенную версию `MultiReader`, которая:

- Объединяет несколько ридеров в один поток: `[]SizedReadSeekCloser -> MultiReader`.
- Всегда читает наружу из внутреннего буфера, который предварительно заполняется фоном.
- Префетчит данные последовательно вперёд, начиная с текущей позиции чтения.
- Лениво запускает префетч: горутина с префетчем стартует только при первом вызове `Read`, а не в конструкторе.
- Поддерживает Seek: если позиция внутри текущего буферного окна, просто двигаем «курсор». Если вне — сбрасываем окно и переинициализируем префетч с новой позиции.
- Корректно закрывается: `Close` должен останавливать фоновую горутину и закрывать все исходные ридеры без утечек и с агрегацией ошибок.

### Интерфейсы и поведение

- `SizedReadSeekCloser`: это интерфейс источника, поддерживающий `Read`, `Seek`, `Close`, и метод `Size()` c размером данных.
- `MultiReader` должен реализовать интерфейс `io.ReadSeekCloser` и иметь метод `Size()`.
- Конструктор `NewMultiReader(buffersNum int, readers ...SizedReadSeekCloser) *MultiReader`:
  - Сохраняет ридеры, считает их суммарный размер и префиксные суммы для быстрого поиска текущего ридера по абсолютной позиции.
  - Выставляет начальные поля для буфера и синхронизации.
  - `buffersNum` задаёт количество блоков в окне буфера; при значении `<= 0` используется значение по умолчанию.
- `Read(p []byte) (int, error)`:
  - Всегда читает из внутреннего буфера. Если данных нет — ждёт пополнение или завершение (EOF/ошибка).
  - При достижении конца общего потока возвращать `io.EOF`.
- `Seek(offset, whence)`:
  - Если новая позиция внутри текущего буферного окна — просто сдвиг «курсор».
  - Если вне окна — сбросить окно, переинициализировать префетч с новой позиции.
  - Позиции вне диапазона `[0, totalSize]` — ошибка.
  - Примечание: сам по себе `Seek` может не запускать префетчер; корректная позиция будет учтена при следующем чтении.
- `Close() error`:
  - Остановить префетч-горутину (graceful shutdown: разбудить горутину, дождаться завершения) и закрыть все исходные ридеры.
  - Повторные вызовы `Close` — возвращают `nil`.
  - После `Close` любые `Read`/`Seek` — `io.ErrClosedPipe`.

### Ограничения и ожидания

- Потокобезопасность: допустимы одновременные вызовы `Read`, `Seek` и `Close` из разных горутин.
- Семантика курсора: используется один общий курсор чтения; параллельные `Read` сериализуются и совместно продвигают позицию.
- Для независимых курсоров создавайте отдельные экземпляры `MultiReader`.
- Префетчер применяет backpressure: при заполненном окне ждёт освобождения слотов.

### Критерии готовности

- Все тесты из папки `hard` проходят (запуск через `compile.sh` и `run.sh`).

### Шаблон кода

```go
/*
type io.ReadSeekCloser interface {
	Read(p []byte) (n int, err error)
	Seek(offset int64, whence int) (int64, error)
	Close() error
}
*/

package main

import "io"

type SizedReadSeekCloser interface {
	io.ReadSeekCloser
	Size() int64
}

type MultiReader struct {
	// put your code here...
}

func NewMultiReader(buffersNum int, rs ...SizedReadSeekCloser) *MultiReader {
	// put your code here...
	return nil
}
```